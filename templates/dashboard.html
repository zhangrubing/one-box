{% extends "base.html" %}{% set page_title="仪表盘" %}{% block content %}
<div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-4 gap-4" id="kpis">
  <div class="kpi card cpu">
    <div class="kpi-label">CPU 使用率</div>
    <div class="kpi-value" id="cpuVal">-</div>
    <div class="kpi-pill"><span id="cpuInfo">-</span></div>
  </div>
  <div class="kpi card mem">
    <div class="kpi-label">内存占用</div>
    <div class="kpi-value" id="memVal">-</div>
    <div class="kpi-pill"><span id="memTotal">-</span></div>
  </div>
  <div class="kpi card gpu">
    <div class="kpi-label">GPU 总体利用</div>
    <div class="kpi-value" id="gpuVal">-</div>
    <div class="kpi-pill"><span id="gpuInfo">-</span></div>
  </div>
  <div class="kpi card alerts">
    <div class="kpi-label"><a href="/alerts">告警（24h）</a></div>
    <div class="kpi-value" id="alertVal">-</div>
    <a href="/alerts"><div class="kpi-pill"><span id="alertInfo">-</span></div></a>
  </div>
</div>

<div class="flex" style="gap:10px;align-items:center;margin-top:10px">
  <span class="small" style="color:var(--muted)">时间范围：</span>
  <div class="seg" id="rangeSeg">
    <button data-r="5m" class="on">最近5分钟</button>
    <button data-r="1h">最近1小时</button>
    <button data-r="24h">最近24小时</button>
  </div>
  <span class="mini-avg" id="avgCpu" style="margin-left:auto"></span>
  <span class="mini-avg" id="avgMem" style="margin-left:12px"></span>
  <span class="mini-avg" id="avgDisk" style="margin-left:12px"></span>
</div>

<div class="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 gap-4 mt-2">
  <div class="card"><div class='section-title'><span>CPU 实时曲线 <span class='mini-avg'></span></span></div><canvas id='cpuChart' style='width:100%;height:220px'></canvas></div>
  <div class="card"><div class='section-title'><span>内存使用率曲线 <span class='mini-avg'></span></span></div><canvas id='memChart' style='width:100%;height:220px'></canvas></div>
  <div class="card"><div class='section-title'><span>磁盘 IO（MB/s） <span class='mini-avg'></span></span></div><canvas id='diskChart' style='width:100%;height:220px'></canvas></div>
</div>

<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
  <div class="card"><div class='section-title'><span>GPU 利用率（平均）</span></div><canvas id='gpuUtilChart' style='width:100%;height:220px'></canvas></div>
  <div class="card"><div class='section-title'><span>GPU 温度（平均）</span></div><canvas id='gpuTempChart' style='width:100%;height:220px'></canvas></div>
</div>

<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mt-4">
  <div class="card">
    <div class="section-title"><span><a href="/alerts">最近告警</a></span></div> <!-- ← 改了标题 -->
    <table class="table"><thead><tr><th>ID</th><th>级别</th><th>标题</th><th>时间</th><th>状态</th></tr></thead><tbody id="sevAlerts"></tbody></table>
  </div>
  <div class="card">
    <div class="section-title"><span>进程 TOP（CPU 30s 采样）</span> <button class="btn" id="sampleTop" style="float:right">刷新采样</button></div>
    <div class="small">采样期间请稍候，请勿频繁点击</div>
    <table class="table"><thead><tr><th>PID</th><th>进程</th><th>用户</th><th>CPU%</th><th>内存</th></tr></thead><tbody id="procTop"></tbody></table>
  </div>
</div>

<script type="module">
import {mountSSE, apiGet, $, formatBytes} from "{{ url_for('static', path='assets/common.js') }}";
import { MiniLine } from "{{ url_for('static', path='assets/chart.js') }}";

const cpuVal=$("#cpuVal"), memVal=$("#memVal"), cpuInfo=$("#cpuInfo"), memTotal=$("#memTotal"), gpuVal=$("#gpuVal"), gpuInfo=$("#gpuInfo"), alertVal=$("#alertVal"), alertInfo=$("#alertInfo");
const sevAlerts=$("#sevAlerts"), procTop=$("#procTop");

// ===== 日志与调试 =====
window.DEBUG_GPU_LOG = false;
window.__METRICS_LOGS = window.__METRICS_LOGS || [];
const __LOG_KEEP = 300;
function dlog(...a){ if(window.DEBUG_GPU_LOG) console.debug('[DASH]',...a); }
function ilog(...a){ if(window.DEBUG_GPU_LOG) console.info('[DASH]',...a); }
function wlog(...a){ if(window.DEBUG_GPU_LOG) console.warn('[DASH]',...a); }

// x 轴时间刻度（5 个等分）
function genXTicks(t0, t1){ const N=5, out=[]; for(let i=0;i<N;i++){ const p=i/(N-1); const dt=(t1-t0)*(1-p); let label='now'; if(dt>0){ if(dt>=3600) label=`-${Math.round(dt/3600)}h`; else if(dt>=60){ const m=Math.round((dt/60)*10)/10; label=`-${String(m).replace(/\.0$/,'')}m`; } else label=`-${Math.round(dt)}s`; } out.push({p,label}); } return out; }

// 图表
const cpuC=new MiniLine('cpuChart',{timeMode:true,max:720,yMin:0,yMax:100,axes:true,ticks:[0,20,40,60,80,100],xTicks:genXTicks});
const memC=new MiniLine('memChart',{timeMode:true,max:720,yMin:0,yMax:100,axes:true,ticks:[0,20,40,60,80,100],xTicks:genXTicks});
const diskC=new MiniLine('diskChart',{timeMode:true,max:720,yMin:0,yMax:50,axes:true,ticks:[0,10,20,30,40,50],xTicks:genXTicks});
const gpuUtilC=new MiniLine('gpuUtilChart',{timeMode:true,max:720,yMin:0,yMax:100,axes:true,ticks:[0,20,40,60,80,100],xTicks:genXTicks});
const gpuTempC=new MiniLine('gpuTempChart',{timeMode:true,max:720,yMin:0,yMax:100,axes:true,ticks:[0,20,40,60,80,100],xTicks:genXTicks});

let range='5m';
let lastAvgCpu=0, lastAvgMem=0, lastAvgDisk=0; let sseRef=null;
let winStart=0, winEnd=0;
let lastSseAt = 0; // SSE 健康检查

function nowSec(){ return Math.floor(Date.now()/1000); }
function windowSecs(){ return range==='24h'? 24*3600 : (range==='1h'? 3600 : 300); }
function setWindowAll(t0, t1){ winStart=t0; winEnd=t1; cpuC.setWindow(t0,t1); memC.setWindow(t0,t1); diskC.setWindow(t0,t1); gpuUtilC.setWindow(t0,t1); gpuTempC.setWindow(t0,t1); }
function fmtTs(ts){ if(!ts && ts!==0) return '-'; const d=new Date(Number(ts)*1000); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; }
function numOrNull(v){ if(v===null||v===undefined) return null; const n=Number(v); return Number.isFinite(n)?n:null; }

// ========== GPU 基本信息只拉一次：成功后停止 ==========
let _gpuFetchedOnce = false;
async function refreshGPUOnce(){
  if (_gpuFetchedOnce) return;
  try{
    const g = await apiGet('/api/system/gpu');
    const gs = g.gpus||[];
    gpuInfo.textContent = (gs.length||0) + ' × GPU';

    const util = gs.map(x=>numOrNull(x.util)).filter(x=>x!==null);
    const temp = gs.map(x=>numOrNull(x.temp)).filter(x=>x!==null);
    const avgUtil = util.length ? util.reduce((a,b)=>a+b,0)/util.length : null;
    const avgTemp = temp.length ? temp.reduce((a,b)=>a+b,0)/temp.length : null;
    dlog('refreshGPUOnce -> gpus:', gs.length, 'avgUtil:', avgUtil, 'avgTemp:', avgTemp);

    _gpuFetchedOnce = true; // 成功一次即可停
  }catch(e){
    wlog('refreshGPUOnce error', e);
  }
}

// ========= 告警：显示 24h 内“所有”告警（不做严重级别过滤） =========
function parseAlertTs(v){
  if (v==null) return NaN;
  if (typeof v==='number') return v>1e12? Math.round(v/1000) : Math.round(v);
  if (typeof v==='string'){
    const n = Number(v);
    if (Number.isFinite(n)) return n>1e12? Math.round(n/1000) : Math.round(n);
    let s = v.trim(); if (!s.includes('T')) s = s.replace(' ', 'T');
    let t = Date.parse(s); if (Number.isNaN(t)) t = Date.parse(s+'Z');
    return Number.isNaN(t) ? NaN : Math.round(t/1000);
  }
  return NaN;
}

async function refreshAlerts(){
  try{
    const r = await apiGet('/api/alerts');
    const rows = (r.items || r.alerts || r.data || []);

    // 统一字段
    const norm = rows.map(x=>{
      const level = String(x.level ?? x.severity ?? x.type ?? '').toUpperCase();
      const title = (x.title ?? x.message ?? x.summary ?? x.name ?? '').toString() || '(无标题)';
      const ts    = parseAlertTs(x.created_at ?? x.timestamp ?? x.ts ?? x.time ?? x.start_time ?? x.happened_at);
      const ackRaw = (x.acknowledged ?? x.ack ?? x.is_ack ?? x.status);
      const ack = (typeof ackRaw === 'boolean') ? ackRaw
                : (typeof ackRaw === 'number')  ? (ackRaw !== 0)
                : (typeof ackRaw === 'string')  ? /ack/i.test(ackRaw)
                : false;
      return { id: x.id ?? x.alert_id ?? x.uid ?? '-', level, title, ts, ack };
    });

    // 仅保留 24h 内
    const nowSecTs = Math.floor(Date.now()/1000);
    const within24h = norm.filter(it => Number.isFinite(it.ts) && (nowSecTs - it.ts) <= 24*3600);

    // KPI：显示所有（24h 内）条数与未确认数
    const openCnt = within24h.filter(x=>!x.ack).length;
    alertVal.textContent  = within24h.length;
    alertInfo.textContent = openCnt ? ('处理中 '+openCnt) : '无未确认';

    // 表格：显示全部（按时间倒序，最多 10 条）
    within24h.sort((a,b)=> b.ts - a.ts);
    const top = within24h.slice(0,10);
    const fmt = (ts)=>{ const d=new Date(ts*1000); const p=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}`; };

    sevAlerts.innerHTML = top.map(x=>`
      <tr>
        <td>${x.id}</td>
        <td>${x.level || '-'}</td>
        <td title="${x.title.replace(/"/g,'&quot;')}">${x.title}</td>
        <td>${fmt(x.ts)}</td>
        <td>${x.ack ? '已确认' : '待处理'}</td>
      </tr>
    `).join('') || '<tr><td colspan=5>暂无告警</td></tr>';

    ilog('[alerts] total=', rows.length, 'within24h=', within24h.length, 'open=', openCnt);
  }catch(e){
    sevAlerts.innerHTML = '<tr><td colspan=5>加载失败</td></tr>';
    wlog('refreshAlerts error', e);
  }
}

async function sampleProcessTop(){
  procTop.innerHTML = '<tr><td colspan=5>采样中（30s）...</td></tr>';
  try{
    const r = await apiGet('/api/process/top?duration=30&limit=10');
    procTop.innerHTML = (r.items||[]).map(p=>`<tr><td>${p.pid}</td><td>${p.name}</td><td>${p.user||''}</td><td>${(p.cpu||0).toFixed(1)}</td><td>${formatBytes(p.mem_rss||0)}</td></tr>`).join('') || '<tr><td colspan=5>无数据</td></tr>';
  }catch(e){ procTop.innerHTML = '<tr><td colspan=5>采样失败</td></tr>'; wlog('sampleProcessTop error', e); }
}
document.getElementById('sampleTop').onclick = sampleProcessTop;

async function loadHistory(){
  const since = nowSec() - (range==='24h'? 24*3600 : (range==='1h'? 3600 : 300));
  const until = nowSec();
  const fields = 'cpu_percent,mem_percent,disk_mb_s,gpu_util_avg,gpu_temp_avg';
  const r = await apiGet(`/api/metrics/system?start=${since}&end=${until}&fields=${fields}`);
  const raw = (r && r.items) ? r.items : [];
  ilog('loadHistory range=', fmtTs(since), '~', fmtTs(until), 'rows=', raw.length);

  setWindowAll(since, until);

  const filtered = raw.filter(it=> Number(it.ts||0) >= since && Number(it.ts||0) <= until).sort((a,b)=>a.ts-b.ts);
  let points = filtered;
  if (range==='24h'){
    const step = Math.ceil((filtered.length||1)/720); if (step>1){ const tmp=[]; for(let i=0;i<filtered.length;i+=step) tmp.push(filtered[i]); points = tmp; }
  }
  cpuC.data=[]; memC.data=[]; diskC.data=[]; gpuUtilC.data=[]; gpuTempC.data=[];
  let maxDisk=0, sumCpu=0, sumMem=0, sumDisk=0, cnt=0;
  let invalidGu=0, invalidGt=0;

  for (const it of points){
    const ts=Number(it.ts||0);
    const cpu=Number(it.cpu_percent||0);
    const mem=Number(it.mem_percent||0);
    const dsk=Number(it.disk_mb_s||0);
    const gu = numOrNull(it.gpu_util_avg ?? it.gpu_util ?? it.gpu?.util);
    const gt = numOrNull(it.gpu_temp_avg ?? it.gpu_temp ?? it.gpu?.temp);

    cpuC.push(Number.isFinite(cpu)?cpu:0, ts);
    memC.push(Number.isFinite(mem)?mem:0, ts);
    diskC.push(Number.isFinite(dsk)?dsk:0, ts);

    if (gu!==null) gpuUtilC.push(gu, ts); else invalidGu++;
    if (gt!==null) gpuTempC.push(gt, ts); else invalidGt++;

    if (Number.isFinite(dsk)) maxDisk = Math.max(maxDisk, dsk);
  }
  ilog('loadHistory points=', points.length, 'gpuUtil invalid=', invalidGu, 'gpuTemp invalid=', invalidGt);

  for (const it of filtered){ sumCpu+=Number(it.cpu_percent||0); sumMem+=Number(it.mem_percent||0); sumDisk+=Number(it.disk_mb_s||0); cnt++; }

  const targetMax = maxDisk>0 ? Math.min(maxDisk*1.3, 5000) : 50;
  function niceNumber(x, round){
    if(!Number.isFinite(x) || x<=0) return 1;
    const exp = Math.floor(Math.log10(x));
    const f = x / Math.pow(10, exp);
    let nf;
    if (round){ nf = (f < 1.5) ? 1 : (f < 3) ? 2 : (f < 7) ? 5 : 10; }
    else { nf = (f <= 1) ? 1 : (f <= 2) ? 2 : (f <= 5) ? 5 : 10; }
    return nf * Math.pow(10, exp);
  }
  function genNiceYTicks(max, desired=6){
    const cap = Math.min(Math.max(max, 10), 5000);
    const min = 0;
    const range = cap - min;
    const niceRange = niceNumber(range, false);
    const spacing = Math.max(1e-12, niceNumber(niceRange / Math.max(2, desired-1), true));
    const graphMin = 0;
    const graphMax = Math.ceil(cap / spacing) * spacing;
    const out=[]; for(let v=graphMin; v<=graphMax + spacing*0.5; v+=spacing){ out.push(Number(v.toFixed(10))); }
    return out;
  }
  const yTicks = genNiceYTicks(targetMax, 6);
  const yTop = yTicks.length ? yTicks[yTicks.length-1] : targetMax;
  diskC.setRange(0, yTop);
  diskC.ticks = yTicks;
  try{ diskC.draw(); }catch(_){ }

  lastAvgCpu = cnt? (sumCpu/cnt) : 0; lastAvgMem = cnt? (sumMem/cnt) : 0; lastAvgDisk = cnt? (sumDisk/cnt) : 0;
  document.getElementById('avgCpu').textContent = `${(lastAvgCpu||0).toFixed(1)}% 平均`;
  document.getElementById('avgMem').textContent = `${(lastAvgMem||0).toFixed(1)}% 平均`;
  document.getElementById('avgDisk').textContent = `${(lastAvgDisk||0).toFixed(1)} MB/s 平均`;
}

function startRealtime(){
  sseRef = mountSSE('/sse/metrics', (d,e)=>{
    if(e.type==='open') ilog('SSE open');
    if(e.type==='error') wlog('SSE error', e);
    if(e.type==='metrics') handleMetricsSnap(d);
  });
}

function handleMetricsSnap(s){
  lastSseAt = Date.now();

  const cpuv = Number(s.cpu_percent||0);
  cpuVal.textContent = Number.isFinite(cpuv)? cpuv.toFixed(0)+'%' : '-';

  let memv = (s.mem_percent!=null && Number.isFinite(Number(s.mem_percent))) ? Number(s.mem_percent)
           : (function(){ const used=Number(s.mem && s.mem.used != null ? s.mem.used : 0);
                           const total=Number(s.mem && s.mem.total != null ? s.mem.total : 0);
                           if (!total || !Number.isFinite(used)||!Number.isFinite(total)) return 0;
                           return used/total*100; })();
  if (!Number.isFinite(memv)) memv = 0;
  memVal.textContent = memv.toFixed(0)+'%';
  const totalGb = Number(s.mem && s.mem.total != null ? s.mem.total : 0) / 1073741824;
  memTotal.textContent = (Number.isFinite(totalGb)? totalGb : 0).toFixed(0)+' GB';

  const ts = Number(s.time || s.ts || nowSec());
  const w = windowSecs();
  setWindowAll(ts - w, ts);
  cpuC.push(Number.isFinite(cpuv)?cpuv:0, ts);
  memC.push(memv, ts);
  const dsk = Number(s.disk_mb_s||0); diskC.push(Number.isFinite(dsk)?dsk:0, ts);

  // GPU —— 只用 SSE 的数据
  const guRaw = (s.gpu_util_avg ?? s.gpu_util ?? (s.gpu && s.gpu.util));
  const gtRaw = (s.gpu_temp_avg ?? s.gpu_temp ?? (s.gpu && s.gpu.temp));
  const gu = numOrNull(guRaw);
  const gt = numOrNull(gtRaw);

  const rec = {
    at_client: new Date().toISOString(),
    ts_server: ts, ts_str: fmtTs(ts),
    cpu_percent: cpuv, mem_percent: memv,
    gpu_util_raw: guRaw, gpu_util_num: gu, valid_gu: (gu!==null),
    gpu_temp_raw: gtRaw,  gpu_temp_num: gt, valid_gt: (gt!==null),
  };
  window.__METRICS_LOGS.push(rec);
  if (window.__METRICS_LOGS.length > __LOG_KEEP) window.__METRICS_LOGS.splice(0, window.__METRICS_LOGS.length-__LOG_KEEP);

  console.groupCollapsed(`[SSE/metrics] ts=${fmtTs(ts)} gu=${gu} (raw:${String(guRaw)}) gt=${gt} (raw:${String(gtRaw)})`);
  console.table([rec]);
  console.groupEnd();

  if (gu!==null) { gpuVal.textContent = Math.round(gu)+'%'; gpuUtilC.push(gu, ts); }
  if (gt!==null) { gpuTempC.push(gt, ts); }

  document.getElementById('avgCpu').textContent = `${Number(cpuv||0).toFixed(1)}% 当前 | ${(lastAvgCpu||0).toFixed(1)}% 平均`;
  document.getElementById('avgMem').textContent = `${Number(memv||0).toFixed(1)}% 当前 | ${(lastAvgMem||0).toFixed(1)}% 平均`;
}

document.getElementById('rangeSeg').addEventListener('click', async (e)=>{
  const b = e.target.closest('button'); if(!b) return; document.getElementById('rangeSeg').querySelectorAll('button').forEach(x=>x.classList.remove('on')); b.classList.add('on');
  range = b.dataset.r; if (sseRef && typeof sseRef.close==='function'){ try{ sseRef.close(); }catch(_){} sseRef=null; }
  await loadHistory(); startRealtime();
});

// 只执行一次
refreshGPUOnce();
refreshAlerts(); setInterval(refreshAlerts, 10000);
sampleProcessTop();
(async()=>{ await loadHistory(); startRealtime(); })();

// 控制台：__METRICS_LOGS.slice(-10)
</script>
{% endblock %}
